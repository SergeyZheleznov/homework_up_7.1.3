// homework_up_7.1.3.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
#include <iostream>

template <typename T>
class Vector
{
public:
    int size; // Это поле определяет размер число элементов, которые может вводить пользователь и которое пользователь заявил при создании массива.
    int capacity; // Это поле является реальным размером массива, оно в два раза больше, чем 
    T* data;// Это адрес начала динамического массива, или динамический массив. Там у нас данные, поэтому и назвали data
public:
    Vector(int n);  // Это конструктор для динамического массива, он запускается автоматически при объявлении объекта нашего массива и он будет требовать при объявлении длины массива
    Vector();       // Этот конструктор без аргументов. Если мы не даём аргументов при создании объекта класса, то будет выбран этот, если аргумент будет задан, то будет выбран предыдущий
    ~Vector();         // Это деструктор, он запускается автоматически, когда объект класса будет выходить из области видимости. Параметров он не принимает.
    T& operator [] (int i);  // Нам будет нужно обращаться к элементам объекта класса (элементам динамического массива) и нам привычно это делать через оператор [] 
                             // Поэтому мы здесь сделали перегрузку этого оператора. Обращаться будем по ссылке, чтобы работать с оригиналом динамического массива, поэтому 
                             // напишем амперсанд. Знак Т это обозначение вместо типа данных, можно поставить любой тип данных, например int
    
    int at(int i)             // этот метод возвращает элемент из массива. Если пользователь написал в скобках двойку, то будет возвращён элемент, который пользователь ввёл вторым.
    {
        return data[i - 1];
    }
    
    int size1()               // данный метод возвращает нам количество элементов, которые заказал при инициализации массива и далее которые он видит
    {
        return size;
    };

    int get_capacity()         // данный метод возвращает нам длину массива    
    {
        return capacity;
    }
    Vector& clear();
    Vector& push_back(T a);
    Vector& init(int n);
};


int main()
{
    setlocale(LC_ALL, "ru");
    
    int N;
    std::cout << "Введите размер массива: ";
    std::cin >> N;
    Vector<int> arr(N);
    std::cout << "Набирайте на клавиатуре числа, которые Вы ходите ввести в массив" << std::endl;
    for (int i = 0; i < N; ++i)
    {
        std::cin >> arr[i];
    }
    std::cout << "Это сформированный Вами массив" << std::endl;

    for (int i = 0; i < N; ++i)
    {
        std::cout << arr[i] << std::endl;
    }
    std::cout << "Проверка работы метода at " << std::endl;
    std::cout << arr.at(3) << std::endl;


    std::cout << "Проверка работы метода push_back " << std::endl;
    std::cout << "Старая длина массива: " << arr.size1() <<std::endl;
    arr.push_back(111);
    std::cout << "Новая длина массива: " << arr.size1() << std::endl;

    for (int i = 0; i < N + 1; ++i)
    {
        std::cout << arr[i] << std::endl;
    }

    std::cout << "Проверка работы метода init " << std::endl;

    arr.init(N);
    for (int i = 0; i < N; ++i)
    {
        std::cout << arr[i] << std::endl;
    }
    return 0;
}

template <typename T>
Vector<T>::Vector()  // Это реализация конструктора. Он выделяет ячейки в памяти. Он вызывается, когда мы создаём объект класса Vector, и не даём в круглые скобки параметров.
{                        
    size = 1;             // Здесь мы определили, что размер данных, доступных пользователю, равен единице
    capacity = 2;         // Здесь мы определили, что реальный размера массива будет равен двум
    data = new T;        // То есть при создании объекта класса без параметров у нас появляется массив с одним элементов. Мне так спокойнее и понятнее.   
}

template <typename T>
Vector<T>::Vector(int n)  // Это реализация конструктора. Он выделяет ячейки в памяти. Количество ячеек равно тому числу, 
{                        // которое мы передали объекту класса в качестве параметра 
    if (n < 1)          // Здесь в этом ифе мы указали, что если пользователь вводит размер массива меньше единицы, например -1 или 0, то принудительно указываем размер равный 1.
    {
        n = 1;
    }
    
    size = n;               // Здесь мы определили,переменная size будет равно числу в круглых скобках, которое вводится при создании объекта класса
    capacity = size * 2;    // Здесь мы определили, что реальный размер массива будет в два раза больше, чем то число, которое вводит пользователь
    data = new T[capacity];  // Здесь мы выделили число ячеек памяти, равную capacity
}

template <typename T>
Vector<T>:: ~Vector()    // Это деструктор, он с помощью оператора delete освобождает память от нашего начального динамического массива data
{
    delete[] data;
}

template <typename T>
Vector<T>& Vector<T>::clear() // это функция, которая очищает массив. Она убирает из него все данные, после этого делает переменную size равной 1, 
{                             // создаёт новый указатель на начало массива и кладёт его в переменную data
    delete[] data;            // после чего возвращает обратно указатель   
    size = 1;  // В результате у нас имеется новый чистый массив, длиной 2. То есть, по сути, просто массив из двух ячеек.
    capacity = 2;
    data = new T[capacity];
    return *this;
}

template <typename T>
Vector<T>& Vector<T>::push_back(T a)   // Этот метод добавляет в области массива, видимой пользователю,  элемент, который находится в круглых скобках
{
    if (size + 1 <= capacity) //Здесь работает логика. Если область массива плюс 1 элемент, которую видит пользователь, меньше или равна реальному размеру массива,  
    {                         //программа добавляет новый элемент в массив после последнего элемента, который видит пользователь, и всё.  
        data[size] = a;       // в другом случае, то есть если места в реальном массиве для добавления элемента уже нет, то начинаются всякие пляски,
        ++size;               // которые описаны после слова else  
    }
    else
    {
        capacity = capacity * 2;           // увеличиваем переменную сapacity, которая определяет длину массива, в два раза

        T* res = new T[capacity];          // сначала выделяется новая память длиной в два раза больше, чем уже была
        res[size] = a;                     // потом  ячейку, которая имеет номер size, кладётся элемент, который мы передали в метод, потом в этот новый массив переписываются все старые элементы
        for (int i = 0; i < size; ++i)
        {
            res[i] = data[i];
        }
        delete[]data;                     // здесь мы освобождаем память, кладём новый массив в переменную data и увеличиваем размер size на единичку.
        data = res;
        ++size;
        return *this;                    // возвращаем ссылку на новый более длинный массив и добавленным элементом. 
    }   
}



template <typename T>
Vector<T>& Vector<T>::init(int n)      // Это функция, которая забирает в параметр число - длину массива, уничтожает старый массив,
{                                      // смотрит, чтобы это число было нормальным, то есть не было отрицательным или нулём (то есть чтобы подходило для указания размера массива)  
    delete[] data;                     // загоняет это число в переменную size, после этого выделает память с числом ячеек, равным этому числу
    if (n < 1)                         // и возвращает указатель на этот новый массив. 
    {                                  // В результате у нас есть новый массив в числом ячеек такой длины, которую мы указали при обращении к этой функции. 1
        n = 1;
    }
    size = n;
    data = new T[n];
    return *this;
}


template <typename T>
T& Vector<T>:: operator [] (int i) // В результате обращения к квадратным скобкам нам будет возвращена ссылка на ячейку памяти. 
{                                  // Если передать в квадратные скобки число, например, 0, то нам будет возвращён адрес самой первой ячейки динамического массива.  
    if (i < 0)           // логика ифа защищает нас от ошибки пользователя. Он может ввести в квадратные скобки число 8, при том, что размер массива равен 5    
    {                    // поэтому мы проверяем, и если пользователь ввёл отрицательное число, то мы принудительно указываем, что это ноль и дадим ему нулевой элемент 
        i = 0;
    }
    else if (i >= size)  // если это число больше размера массива, то мы принудительно сделаем это число равным size - 1, то есть размер массива минус 1
    {                    // и пользователь получит последнее число в массиве. 
        i = size - 1;
    }
    return data[i];
}

